#version 330 core

in vec3 vertex_position_cameraspace;
flat in vec3 vertex_normal_cameraspace;
in vec2 vertex_UV;
in mat3 TBN ;
in vec3 light_position_tangen;
in mat4 VM;
in vec4 FragPosLightSpace;
in vec4 FragPosScreenSpace;
uniform mat4 V;
mat3 IV =mat3(inverse(V));
in vec4 vpcs;
in vec3 vertex_pos;
// uniform variables (lightPosition_worldspace, V, M)
uniform vec3 light_position_cameraspace;
uniform vec3 lightcolor;
uniform vec3 camera_pos;
uniform float light_power;
uniform float time_s;
uniform float Ns;
uniform mat4 lightSpaceMatrix;
// Task 5.3: define uniform variables for the texture coordinates
// (diffuseColorSampler, specularColorSampler)
uniform sampler2D diffuseColorSampler;
uniform sampler2D specularColorSampler;
uniform sampler2D NormalMap;
uniform sampler2D shadowMap;
uniform sampler2D shadowMap2;
uniform sampler2D shadowMap3;

// output data
layout (location = 0) out vec4 fragment_color;
layout (location = 1) out vec4 fragment_color2;
//uniform material






float ShadowCalculation(vec4 fragPosLightSpace, sampler2D shadowmap)//returns 1 if there is no shadow  
{   
    
    vec3 projCoords = fragPosLightSpace.xyz / fragPosLightSpace.w; //clipspace to screenspace
    projCoords = projCoords * 0.5 + 0.5; // transform to [0,1] range from -1,1 vieport
    float closestDepth = texture(shadowmap, projCoords.xy).r;
    float currentDepth = projCoords.z;
    float bias = 0.0005;
    float shadow = currentDepth - bias < closestDepth  ? 1.0 : 0.6;
    
    return shadow;
}



void main()
{
    
    fragment_color = vec4(1, 1, 1, 1);

    vec3 Ls = lightcolor;
    vec3 Ld = lightcolor;
    vec3 La = vec3(0.1,0.1,0.1);
  
    vec3 Ia  = La * vec3(texture(diffuseColorSampler, vertex_UV).rgb) ;
    
    vec3 normal =vec3(texture(NormalMap, vertex_UV).rgb);
    normal = (2*normal)-1;
    normal = normalize(TBN * normal);

    vec3 N = normalize(normal);
    
    vec3 L = normalize(light_position_cameraspace - vertex_position_cameraspace);
    float cosTheta = clamp(dot(L,N), 0, 1);

    vec3 Id = Ld * vec3(texture(diffuseColorSampler, vertex_UV).rgb) * cosTheta;
    fragment_color = vec4(Ia + Id, 1.0); 

    vec3 R = reflect(-L, N);
    
    vec3 E = normalize(-vertex_position_cameraspace);
    

    float cosAlpha = clamp(dot(E,R),0,1);

    float specular_factor = pow (cosAlpha, Ns)  ;
    vec3 Is = Ls * vec3(texture(specularColorSampler, vertex_UV).rgb) * specular_factor;
    fragment_color = vec4(Ia + Id + Is, 1.0); 

  
    float dist = length(light_position_cameraspace - vertex_position_cameraspace);
    float dist_sq = dist * dist ;
    //float light_power = 10.0f;
    float shadow = ShadowCalculation(FragPosLightSpace,shadowMap);
    float shadow2 = ShadowCalculation(FragPosLightSpace,shadowMap2);
    float shadow3 = ShadowCalculation(FragPosLightSpace,shadowMap3);;
    vec3 color = vec3(1,1,1);
    if(shadow == 1.0)
        color = vec3(1,0.7,0.7);
    else if(shadow2 ==1)
        color = vec3(0.7,1,0.7);
    else if(shadow3 ==1)
        color = vec3(0.7,0.7,1);

    shadow = max(shadow,shadow2);
    shadow = max(shadow, shadow3);

    
    
    
    fragment_color =  vec4((Ia +  (Id * light_power/dist_sq) *  shadow+ (Is * light_power/dist_sq) * shadow) * color ,1.0);
    
    
    const float n_steps =240;
    const float exposure = 0.6f;
    const float decay = 0.96 ; // 0.96815 
    const float density  = 0.926;//0.926;
    const float weight  = 0.487; // 0.587
    float illuminationDecay = 1;
    float volume = 80;
    float volumePerStep = volume/n_steps;

    vec3 ray =  vertex_pos- camera_pos;
    vec3 rayStep = ray/n_steps;
    vec3 newcamera_pos = camera_pos;
    vec3 vol = vec3(0,0,0);
    
    shadow = shadow2 =shadow3 =0;

    vec4 fpls;
    vec3 projCoords;
    float closestDepth,currentDepth;
    for(int i =0 ; i<n_steps ; i++){
        
        shadow = ShadowCalculation(lightSpaceMatrix * vec4(newcamera_pos,1),shadowMap);
        shadow2 = ShadowCalculation(lightSpaceMatrix * vec4(newcamera_pos,1),shadowMap2);
        shadow3 = ShadowCalculation(lightSpaceMatrix * vec4(newcamera_pos,1),shadowMap3);
        
        if(shadow == 1){
            vol += vec3(0.1,0.1,0.1) *  illuminationDecay * weight * vec3(volumePerStep,0,0);
            illuminationDecay*=decay;
        }
        if(shadow2 == 1){
            vol += vec3(0.1,0.1,0.1) *  illuminationDecay * weight * vec3(0,volumePerStep,0);
            illuminationDecay*=decay;
        }
        if(shadow3 == 1){
            vol += vec3(0.1,0.1,0.1) *  illuminationDecay * weight * vec3(0,0,volumePerStep) ;
            illuminationDecay*=decay;
        }
        newcamera_pos += rayStep;
        
    }
    
    
    fragment_color2 =  vec4(vol,1);
    
}