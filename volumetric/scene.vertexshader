#version 330 core

// construct input layout for the corresponding attributes
// (vertexPosition_modelspace, vertexNormal_modelspace, vertexUV)
layout(location = 0) in vec3 vertexPosition_modelspace;
layout(location = 1) in vec3 vertexNormal_modelspace;
layout(location = 2) in vec2 vertexUV;
layout (location = 3) in vec3 aTangent;
layout (location = 4) in vec3 aBitangent;  


// Output variables (position_modelspace, normal_modelspace and UV coordinates), 
// that will be interpolated for each fragment
out vec3 vertex_position_cameraspace;
flat out vec3 vertex_normal_cameraspace;
out vec2 vertex_UV;
out mat3 TBN;
out vec3 light_position_tangen;
out mat4 VM;
out vec4 FragPosLightSpace;
out vec4 FragPosScreenSpace;
out vec4 vpcs;
// uniforms (P, V, M)
uniform mat4 P;
uniform mat4 V;
uniform mat4 M;
uniform mat4 lightSpaceMatrix;
uniform vec3 light_position_cameraspace;
out vec3 vertex_pos;
void main()
{
    vec3 T = normalize(vec3(V*M*vec4(aTangent,   0.0)));
    vec3 B = normalize(vec3(V*M*vec4(aBitangent,   0.0)));
    vec3 N = normalize(vec3(V*M*vec4(vertexNormal_modelspace, 0.0)));
    TBN = mat3(T, B, N);

    //light_position_tangen =  light_position_cameraspace;
    // Output position of the vertex, in clip space : MVP * position
    gl_Position =  P * V * M * vec4(vertexPosition_modelspace, 1);
    vpcs=  V * M * vec4(vertexPosition_modelspace, 1);
    FragPosScreenSpace = P * V * M * vec4(vertexPosition_modelspace, 1);
    //FragPosLightSpace = lightSpaceMatrix * M * vec4(vertexPosition_modelspace, 1.0); 
    FragPosLightSpace = lightSpaceMatrix * M * vec4(vertexPosition_modelspace, 1.0);// lightspacematrix = P*V
    //gl_Position = lightSpaceMatrix * M * vec4(vertexPosition_modelspace, 1.0);

    // Task 3.1: propagate the position of the vertex to fragment shader
    vertex_position_cameraspace = vec3(V*M*vec4(vertexPosition_modelspace, 1.0));
    //vertex_position_cameraspace = TBN * vertex_position_cameraspace;
    // Task 3.2: propagate the normal of the vertex to fragment shader
    vertex_normal_cameraspace = vec3(V*M*vec4(vertexNormal_modelspace, 0.0)); 

    vertex_pos = vec3(M*vec4(vertexPosition_modelspace, 1.0));
    // Task 5.2: propagate the UV coordinates   
    vertex_UV = vertexUV;
    VM = V;
}
