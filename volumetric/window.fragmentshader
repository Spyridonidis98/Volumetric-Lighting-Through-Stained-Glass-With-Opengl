#version 330 core
//out vec4 FragColor;
layout (location = 0) out vec4 fragment_color;
layout (location = 1) out vec4 fragment_color2;

in vec3 vertex_pos;
uniform float is_sun;
uniform vec3 camera_pos;
uniform sampler2D shadowMap;
uniform sampler2D shadowMap2;
uniform sampler2D shadowMap3;
uniform mat4 lightSpaceMatrix;
//layout(location = 0) out float fragmentdepth;

float ShadowCalculation(vec4 fragPosLightSpace, sampler2D shadowmap)
{   
   

    vec3 projCoords = fragPosLightSpace.xyz / fragPosLightSpace.w; //clipspace to screenspace
    // transform to [0,1] range from -1,1
    projCoords = projCoords * 0.5 + 0.5;//vieport
    float closestDepth = texture(shadowmap, projCoords.xy).r;
    float currentDepth = projCoords.z;
    float bias = 0.0005;
    float shadow = currentDepth - bias < closestDepth  ? 1.0 : 0.6;
    
    return shadow;
}

void main(){



	if(is_sun==0)
	fragment_color = vec4(1, 0,0, 0.2);
	else if(is_sun ==1)
    fragment_color = vec4(0 ,1 ,0, 0.2);
	else 
	fragment_color = vec4(0 ,0 ,1, 0.2);


    
    float shadow,shadow2,shadow3;
    const float n_steps =240;
    const float exposure = 0.6f;
    const float decay = 0.96815 ; // 0.96815 
    const float density  = 0.926;//0.926;
    const float weight  = 0.587; // 0.587
    float illuminationDecay = 1;
    float volume = 80;
    float volumePerStep = volume/n_steps;
    vec3 ray =  vertex_pos- camera_pos;
    vec3 rayStep = ray/n_steps;
    vec3 newcamera_pos = camera_pos;
    vec3 vol = vec3(0,0,0);

    for(int i =0 ; i<n_steps ; i++){
        
         
        shadow = ShadowCalculation(lightSpaceMatrix * vec4(newcamera_pos,1),shadowMap);
        shadow2 = ShadowCalculation(lightSpaceMatrix * vec4(newcamera_pos,1),shadowMap2);
        shadow3 = ShadowCalculation(lightSpaceMatrix * vec4(newcamera_pos,1),shadowMap3);
        
        if(shadow == 1){
            vol += vec3(0.1,0.1,0.1) *  illuminationDecay * weight * vec3(volumePerStep,0 ,0) ;
            illuminationDecay*=decay;
        }
        if(shadow2 == 1){
            vol += vec3(0.1,0.1,0.1) *  illuminationDecay * weight * vec3(0,volumePerStep,0) ;
            illuminationDecay*=decay;
        }
        if(shadow3 == 1){
            vol += vec3(0.1,0.1,0.1) *  illuminationDecay * weight * vec3(0,0,volumePerStep) ;
            illuminationDecay*=decay;
        }
        newcamera_pos += rayStep;
        //illuminationDecay *= decay;
    }
    fragment_color += vec4(vol,0);
    fragment_color2 =  vec4(vol,1);


}